#include "mem/vmm.h"
#include "mem/heap.h"
#include "stdlib/stdlib.h"
#include "drivers/pcie.h"
#include "drivers/timer.h"
#include "align.h"
#include "drivers/ahci.h"
struct ahci_info ahciInfo = {0};
struct ahci_cmd_list_desc cmdListDesc = {0};
int ahci_init(void){
	if (ahci_get_info(&ahciInfo)!=0)
		return -1;
	if (virtualMapPages((uint64_t)ahciInfo.pBase, (uint64_t)ahciInfo.pBase, PTE_RW|PTE_NX, 2, 1, 0, PAGE_TYPE_MMIO)!=0){
		printf(L"failed to map AHCI controller registers\r\n");
		return -1;
	}
	printf(L"AHCI base: %p\r\n", (void*)ahciInfo.pBase);
	printf(L"AHCI controller bus: %d, device: %d, function: %d\r\n", ahciInfo.bus, ahciInfo.dev, ahciInfo.func);
	if (ahci_init_cmd_list(&cmdListDesc)!=0){
		printf(L"failed to initialize cmd list\r\n");
		return -1;
	}
	uint32_t ahci_version = 0;
	ahci_read_dword(0x10, &ahci_version);
	printf(L"AHCI controller version: 0x%x\r\n", ahci_version);
	for (uint32_t i = 0;i<AHCI_MAX_PORTS;i++){
		if (ahci_drive_exists(i)!=0)
			continue;
		printf(L"AHCI device at port: %d\r\n", i);
		struct ahci_drive_info driveInfo = {0};
		if (ahci_get_drive_info(i, &driveInfo)!=0){
			printf(L"failed to get drive info\r\n");
			continue;
		}
	}
	return 0;
}
int ahci_get_info(struct ahci_info* pInfo){
	if (!pInfo)
		return -1;
	if (ahciInfo.pBase){
		*pInfo = ahciInfo;
		return 0;
	}
	uint8_t bus = 0;
	uint8_t dev = 0;
	uint8_t func = 0;
	uint64_t pBase = 0;
	if (pcie_get_device_by_class(0x01, 0x06, &bus, &dev, &func)!=0){
		printf(L"failed to get AHCI controller\r\n");
		return -1;
	}
	if (pcie_get_bar(bus, dev, func, 5, &pBase)!=0){
		printf(L"failed to get AHCI base\r\n");
		return -1;
	}
	if (!pBase){
		printf(L"invalid AHCI base\r\n");
		return -1;
	}
	ahciInfo.bus = bus;
	ahciInfo.dev = dev;
	ahciInfo.func = func;
	ahciInfo.pBase = pBase;
	return 0;
}
int ahci_write_byte(uint64_t offset, uint8_t value){
	if (!ahciInfo.pBase)
		return -1;
	volatile uint8_t* pReg = (uint8_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pReg = value;	
	return 0;
}
int ahci_read_byte(uint64_t offset, uint8_t* pValue){
	if (!ahciInfo.pBase)
		return -1;
	if (!pValue)
		return -1;
	volatile uint8_t* pReg = (uint8_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pValue = *pReg;
	return 0;
}
int ahci_write_word(uint64_t offset, uint16_t value){
	if (!ahciInfo.pBase)
		return -1;
	volatile uint16_t* pReg = (uint16_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pReg = value;	
	return 0;
}
int ahci_read_word(uint64_t offset, uint16_t* pValue){
	if (!ahciInfo.pBase)
		return -1;
	if (!pValue)
		return -1;
	volatile uint16_t* pReg = (uint16_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pValue = *pReg;
	return 0;
}
int ahci_write_dword(uint64_t offset, uint32_t value){
	if (!ahciInfo.pBase)
		return -1;
	volatile uint32_t* pReg = (uint32_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pReg = value;	
	return 0;
}
int ahci_read_dword(uint64_t offset, uint32_t* pValue){
	if (!ahciInfo.pBase)
		return -1;
	if (!pValue)
		return -1;
	volatile uint32_t* pReg = (uint32_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pValue = *pReg;
	return 0;
}
int ahci_write_qword(uint64_t offset, uint64_t value){
	if (!ahciInfo.pBase)
		return -1;
	volatile uint64_t* pReg = (uint64_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pReg = value;	
	return 0;
}
int ahci_read_qword(uint64_t offset, uint64_t* pValue){
	if (!ahciInfo.pBase)
		return -1;
	if (!pValue)
		return -1;
	volatile uint64_t* pReg = (uint64_t*)(((uint8_t*)ahciInfo.pBase)+offset);
	*pValue = *pReg;
	return 0;
}
int ahci_get_port_base(uint8_t port, volatile struct ahci_port_mem** ppBase){
	if (!ppBase)
		return -1;
	uint64_t port_offset = AHCI_PORT_OFFSET(port);
	volatile struct ahci_port_mem* pBase = (struct ahci_port_mem*)(ahciInfo.pBase+port_offset);
	*ppBase = pBase;
	return 0;
}
int ahci_drive_exists(uint8_t drive_port){
	if (drive_port>32)
		return -1;
	volatile struct ahci_port_mem* pPort = (struct ahci_port_mem*)0x0;
	if (ahci_get_port_base(drive_port, &pPort)!=0)
		return -1;
	if (pPort->signature!=AHCI_SATA_SIGNATURE){
		return -1;
	}
	return 0;
}
int ahci_init_cmd_list(struct ahci_cmd_list_desc* pCmdListDesc){
	if (!pCmdListDesc)
		return -1;
	volatile struct ahci_cmd_hdr* pCmdList = (volatile struct ahci_cmd_hdr*)0x0;
	if (virtualAllocPage((uint64_t*)&pCmdList, PTE_RW|PTE_NX, 0, PAGE_TYPE_MMIO)!=0)
		return -1;
	uint64_t maxTableSize = sizeof(struct ahci_cmd_table)+(AHCI_MAX_PRDT_ENTRIES*sizeof(struct ahci_prdt_entry));
	uint64_t cmdTableListSize = maxTableSize*AHCI_MAX_CMD_ENTRIES;
	uint64_t cmdTableListPages = align_up(cmdTableListSize, PAGE_SIZE)/PAGE_SIZE;
	volatile struct ahci_cmd_table* pCmdTableList = (volatile struct ahci_cmd_table*)0x0;
	printf(L"cmd list pages: %d\r\n", cmdTableListPages);
	if (virtualAllocPages((uint64_t*)&pCmdTableList, cmdTableListPages, PTE_RW|PTE_NX, 0, PAGE_TYPE_MMIO)!=0)
		return -1;
	memset((void*)pCmdList, 0, sizeof(struct ahci_cmd_hdr)*AHCI_MAX_CMD_ENTRIES);
	memset((void*)pCmdTableList, 0, cmdTableListSize);
	pCmdListDesc->pCmdList = pCmdList;
	pCmdListDesc->pCmdTableList = pCmdTableList;
	pCmdListDesc->cmdTableListPages = cmdTableListPages;
	pCmdListDesc->currentEntry = 0;
	return 0;
}
int ahci_deinit_cmd_list(struct ahci_cmd_list_desc* pCmdListDesc){
	if (!pCmdListDesc)
		return -1;
	if (virtualFreePage((uint64_t)pCmdListDesc->pCmdList, 0)!=0)
		return -1;
	if (virtualFreePages((uint64_t)pCmdListDesc->pCmdTableList, pCmdListDesc->cmdTableListPages)!=0)
		return -1;
	return 0;
}
int ahci_push_cmd_table(struct ahci_cmd_list_desc* pCmdListDesc, uint64_t prdt_cnt, volatile struct ahci_cmd_hdr** ppCmdHdr){
	if (!pCmdListDesc||!ppCmdTable)
		return -1;
	if (pCmdListDesc->currentEntry>=AHCI_MAX_CMD_ENTRIES)
		return -1;
	if (prdt_cnt>AHCI_MAX_PRDT_ENTRIES)
		return -1;
	volatile struct ahci_cmd_hdr* pCmdHdr = pCmdListDesc->pCmdList+pCmdListDesc->currentEntry;
	if (((uint64_t)pCmdHdr)%128)
		return -1;
	volatile struct ahci_cmd_table* pCmdTable = pCmdListDesc->pCmdTableList+pCmdListDesc->currentEntry;
	if (((uint64_t)pCmdTable)%128)
		return -1;
	uint64_t cmdTableSize = sizeof(struct ahci_cmd_table)+(prdt_cnt*sizeof(struct ahci_prdt_entry));
	memset((void*)pCmdTable, 0, cmdTableSize);
	pCmdHdr->cmd_table_base = (uint64_t)pCmdTable;
	pCmdHdr->prdt_len = prdt_cnt;
	*ppCmdTable = pCmdTable;
	pCmdListDesc->currentEntry++;
	return 0;
}
int ahci_pop_cmd_table(struct ahci_cmd_list_desc* pCmdListDesc){
	if (!pCmdListDesc)
		return -1;
	if (!pCmdListDesc->currentEntry)
		return -1;
	volatile struct ahci_cmd_hdr* pTop = (pCmdListDesc->pCmdList+(pCmdListDesc->currentEntry-1));
	volatile struct ahci_cmd_table* pCmdTable = (volatile struct ahci_cmd_table*)pTop->cmd_table_base;
	pCmdListDesc->currentEntry--;
	return 0;
}
int ahci_write_prdt(volatile struct ahci_cmd_table* pCmdTable, uint64_t prdt_index, uint64_t va, uint64_t size){
	if (!pCmdTable||!va)
		return -1;
	volatile struct ahci_prdt_entry* pPrdt = (volatile struct ahci_prdt_entry*)(pCmdTable->prdt_list+prdt_index);
	uint64_t pa = 0;
	if (virtualToPhysical(va, &pa)!=0)
		return -1;
	pPrdt->base = pa;
	pPrdt->byte_cnt = size-1;
	pPrdt->reserved0 = 0;
	pPrdt->interrupt = 0;
	pPrdt->reserved1 = 0;
	return 0;
}
int ahci_run_port(uint8_t port){
	volatile struct ahci_port_mem* pPort = (struct ahci_port_mem*)0x0;
	if (ahci_get_port_base(port, &pPort)!=0)
		return -1;
	while (pPort->cmd&(1<<4)){};
	pPort->cmd|=(1<<4);
	pPort->cmd|=(1<<0);
	while (!(pPort->cmd&(1<<15))){};
	return 0;
}
int ahci_stop_port(uint8_t port){
	volatile struct ahci_port_mem* pPort = (struct ahci_port_mem*)0x0;
	if (ahci_get_port_base(port, &pPort)!=0)
		return -1;
	pPort->cmd&=~(1<<0);
	pPort->cmd&=~(1<<4);
	while (pPort->cmd&(1<<4)){};
	return 0;
}
int ahci_get_drive_info(uint8_t drive_port, struct ahci_drive_info* pDriveInfo){
	if (!pDriveInfo)
		return -1;
	volatile struct ahci_port_mem* pPort = (struct ahci_port_mem*)0x0;
	if (ahci_get_port_base(drive_port, &pPort)!=0)
		return -1;
	volatile struct ahci_cmd_table* pCmdTable = (volatile struct ahci_cmd_table*)0x0;
	if (ahci_push_cmd_table(&cmdListDesc, 1, &pCmdTable)!=0){
		printf(L"failed to push cmd to cmd table\r\n");
		return -1;
	}
	printf(L"successfully pushed cmd\r\n");
	volatile struct ahci_fis_host_to_dev* pIdentFis = (volatile struct ahci_fis_host_to_dev*)pCmdTable->fis;
	memset((void*)pIdentFis, 0, sizeof(struct ahci_fis_host_to_dev));
	pIdentFis->fis_type = AHCI_FIS_TYPE_H2D;
	pIdentFis->c = 1;
	pIdentFis->cmd = AHCI_CMD_IDENT;
	pPort->fis_base = (uint64_t)pIdentFis;
	unsigned char driveData[512] = {0};
	if (ahci_write_prdt(pCmdTable, 0, (uint64_t)driveData, sizeof(driveData))!=0){
		printf(L"failed to write drive data prdt\r\n");
		ahci_pop_cmd_table(&cmdListDesc);
		return -1;
	}
	if (ahci_run_port(drive_port)!=0){
		printf(L"failed to run port\r\n");
		ahci_pop_cmd_table(&cmdListDesc);
		return -1;
	}
	while (pPort->cmd&(1<<4)){};
	sleep(50);
	if (pPort->sata_error){
		printf(L"failed to read drive data sector\r\n");
		ahci_pop_cmd_table(&cmdListDesc);
		return -1;
	}
	if (ahci_stop_port(drive_port)!=0){
		printf(L"failed to stop port\r\n");
		ahci_pop_cmd_table(&cmdListDesc);
		return -1;
	}
	uint16_t sectors_low = *(((uint16_t*)driveData)+60);
	uint16_t sectors_high = *(((uint16_t*)driveData)+61);
	printf(L"drive sectors low: %d high: %d\r\n", sectors_low, sectors_high);
	for (uint64_t i = 0;i<sizeof(driveData)/sizeof(uint64_t);i++){
		if (driveData[i]!=0)
			printf(L"no zero at offset\r\n");
	}
	if (ahci_pop_cmd_table(&cmdListDesc)!=0){
		printf(L"failed to pop cmd off cmd table\r\n");
		return -1;
	}
	return 0;
}
