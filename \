#include "mem/vmm.h"
#include "mem/heap.h"
#include "drivers/timer.h"
#include "stdlib/stdlib.h"
#include "subsystem/subsystem.h"
#include "cpu/interrupt.h"
#include "cpu/thread.h"
static struct subsystem_desc* pSubsystemDesc = (struct subsystem_desc*)0x0;
struct thread_t* pFirstThread = (struct thread_t*)0x0;
struct thread_t* pLastThread = (struct thread_t*)0x0;
struct thread_t* pCurrentThread = (struct thread_t*)0x0;
int threads_init(void){
	if (subsystem_init(&pSubsystemDesc, 65536)!=0)
		return -1;
	return 0;
}
int thread_register(struct thread_t* pThread, uint64_t* pTid){
	if (!pThread||!pTid)
		return -1;
	uint64_t tid = 0;
	if (subsystem_alloc_entry(pSubsystemDesc, (unsigned char*)pThread, &tid)!=0)
		return -1;
	if (!pFirstThread){
		pFirstThread = pThread;
	}
	if (pLastThread){
		pLastThread->pFlink = pThread;
		pThread->pBlink = pLastThread;
	}
	pLastThread = pThread;
	*pTid = tid;
	return 0;
}
int thread_unregister(uint64_t tid){
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0)
		return -1;
	if (!pThread)
		return -1;
	if (subsystem_free_entry(pSubsystemDesc, tid)!=0)
		return -1;
	if (pFirstThread==pThread)
		pFirstThread = pThread->pFlink;
	if (pLastThread==pThread)
		pLastThread = pThread->pBlink;
	if (pThread->pFlink)
		pThread->pFlink->pBlink = pThread->pBlink;
	if (pThread->pBlink)
		pThread->pBlink->pFlink = pThread->pFlink;
	return 0;
}
KAPI int thread_create(uint64_t rip, uint64_t stackSize, uint64_t* pTid, uint64_t argument){
	if (!pTid||!rip)
		return -1;
	__asm__ volatile("cli");
	if (!stackSize||stackSize<4096)
		stackSize = THREAD_DEFAULT_STACK_SIZE;
	unsigned char* pStack = (unsigned char*)0x0;
	uint64_t stackGuardPages = 16;
	uint64_t realStackSize = stackSize+(stackGuardPages*2*PAGE_SIZE);
	if (virtualAlloc((uint64_t*)&pStack, realStackSize, PTE_RW|PTE_NX, 0, PAGE_TYPE_NORMAL)!=0){
		__asm__ volatile("sti");	
		return -1;
	}
	unsigned char* pFirstGuard = pStack;
	unsigned char* pLastGuard = pStack+(stackGuardPages*PAGE_SIZE)+stackSize;
	if (virtualProtectPages((uint64_t)pFirstGuard, stackGuardPages, 0)!=0){
		virtualFree((uint64_t)pStack, realStackSize);
		__asm__ volatile("sti");
		return -1;
	}
	if (virtualProtectPages((uint64_t)pLastGuard, stackGuardPages, 0)!=0){
		virtualFree((uint64_t)pStack, realStackSize);
		__asm__ volatile("sti");
		return -1;
	}
	pStack+=stackGuardPages*PAGE_SIZE;
	struct thread_t* pThread = (struct thread_t*)kmalloc(sizeof(struct thread_t));
	if (!pThread){
		virtualFree((uint64_t)pStack, realStackSize);
		__asm__ volatile("sti");
		return -1;
	}
	memset((void*)pThread, 0, sizeof(struct thread_t));
	uint64_t rsp = ((uint64_t)pStack)+stackSize-64;
	struct thread_context_t* pContext = &pThread->context;
	uint64_t tid = 0;
	if (thread_register(pThread, &tid)!=0){
		kfree((void*)pThread);
		virtualFree((uint64_t)pStack, realStackSize);
		__asm__ volatile("sti");
		return -1;
	}
	uint64_t rflags = get_rflags();
	pContext->rip = rip;
	pContext->rsp = rsp;
	pContext->rbp = 0x0;
	pContext->rcx = tid;
	pContext->rdx = argument;
	pContext->rflags = rflags;
	pThread->priority = THREAD_PRIORITY_NORMAL;
	pThread->tid = tid;
	pThread->start_rip = pContext->rip;
	pThread->start_rsp = pContext->rsp;
	*pTid = tid;
	__asm__ volatile("sti");
	return 0;
}
KAPI int thread_destroy(uint64_t tid){
	__asm__ volatile("cli");
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0){
		__asm__ volatile("sti");
		return -1;
	}
	kfree((void*)pThread);
	if (thread_unregister(tid)!=0){
		__asm__ volatile("sti");
		return -1;
	}
	__asm__ volatile("sti");
	return 0;
}
KAPI int thread_get_status(uint64_t tid, uint64_t* pStatus){
	if (!pStatus)
		return -1;
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0)
		return -1;
	if (!pThread){
		return -1;
	}
	*pStatus = pThread->status;
	return 0;
}
KAPI int thread_set_status(uint64_t tid, uint64_t status){
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0)
		return -1;
	if (!pThread)
		return -1;
	pThread->status = status;
	return 0;
}
KAPI int thread_get_priority(uint64_t tid, uint64_t* pPriority){
	if (!pPriority)
		return -1;
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0)
		return -1;
	if (!pThread)
		return -1;
	*pPriority = pThread->priority;
	return 0;
}
KAPI int thread_set_priority(uint64_t tid, uint64_t priority){
	struct thread_t* pThread = (struct thread_t*)0x0;
	if (subsystem_get_entry(pSubsystemDesc, tid, (uint64_t*)&pThread)!=0)
		return -1;
	if (!pThread)
		return -1;
	pThread->priority = priority;
	return 0;
}
KAPI int thread_yield(void){
	struct thread_t* pNextThread = pCurrentThread->pFlink;
	if (!pNextThread)
		return -1;
	if (pNextThread==pCurrentThread)
		return 0;
	if (pCurrentThread==pFirstThread)
		pFirstThread = pCurrentThread->pFlink;
	if (pCurrentThread==pLastThread)
		pLastThread = pCurrentThread->pBlink;
	if (!pLastThread)
		pLastThread = pFirstThread;
	if (pNextThread->pFlink)
		pNextThread->pFlink->pBlink = pCurrentThread;
	if (pCurrentThread->pBlink)
		pCurrentThread->pBlink->pFlink = pNextThread;
	pCurrentThread->pFlink = pNextThread->pFlink;
	pCurrentThread->pBlink = pNextThread;
	return 0;
}
